{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentazione Cinemille Panoramica del Progetto Il progetto \u00e8 stato realizzato con: Backend : Spring Boot, Spring Security, JPA/Hibernate Frontend : Angular 19 + Angular Material Database : PostgreSQL VCS : Git IDE : IntelliJ L'applicazione permette visualizzare una lista completa delle programmazioni, oppure solo la lista dei film in programmazione nella settimana attuale, in base al ruolo dell'utente/servizio. Struttura del Progetto Il progetto \u00e8 organizzato con una struttura Maven: cinemille/ \u251c\u2500\u2500 backend/ # Spring Boot \u2514\u2500\u2500 frontend/ # Angular Per una spiegazione pi\u00f9 dettagliata, vedere la sezione \"Architettura\" Funzionalit\u00e0 Principali Autenticazione : Sistema di autenticazione basato su JWT Lista Film : Storico completo delle programmazioni dei film nelle varie sale","title":"Home"},{"location":"#documentazione-cinemille","text":"","title":"Documentazione Cinemille"},{"location":"#panoramica-del-progetto","text":"Il progetto \u00e8 stato realizzato con: Backend : Spring Boot, Spring Security, JPA/Hibernate Frontend : Angular 19 + Angular Material Database : PostgreSQL VCS : Git IDE : IntelliJ L'applicazione permette visualizzare una lista completa delle programmazioni, oppure solo la lista dei film in programmazione nella settimana attuale, in base al ruolo dell'utente/servizio.","title":"Panoramica del Progetto"},{"location":"#struttura-del-progetto","text":"Il progetto \u00e8 organizzato con una struttura Maven: cinemille/ \u251c\u2500\u2500 backend/ # Spring Boot \u2514\u2500\u2500 frontend/ # Angular Per una spiegazione pi\u00f9 dettagliata, vedere la sezione \"Architettura\"","title":"Struttura del Progetto"},{"location":"#funzionalita-principali","text":"Autenticazione : Sistema di autenticazione basato su JWT Lista Film : Storico completo delle programmazioni dei film nelle varie sale","title":"Funzionalit\u00e0 Principali"},{"location":"architettura/","text":"Architettura del Sistema Backend Il backend \u00e8 stato strutturato seguendo le indicazioni standard del pattern MVC Package principali Model : Rappresentano le entit\u00e0 del dominio, mappate direttamente sul DB tramite l'ORM di Hibernate Repository : Si interfacciano con il Database, estendono JpaRepository in modo da offrire operazioni standard di CRUD gi\u00e0 implementate sulle entit\u00e0 Controller : Gestiscono le richieste HTTP e definiscono gli endpoint dell'API REST Service : Implementano la logica di business Config : Configurazioni di base per CSRF, CORS, Middleware per Logging e controllo JWT, Esclusione URL da autenticazione obbligatoria Dipendenze Definite nel pom.xml del backedn Spring Boot Web Spring Data JPA Spring Security JWT PostgreSQL Frontend (Angular 19) Comunicazione con il backend tramite chiamate http all'API Rest Gestione dello stato dell'applicazione, principalmente sullo stato di autenticazione dell'utente Gestione route guard in base allo stato di autenticazione dell'utente Package Principali Core : Contiene logica fondamentale, servizi e guard Servizi : Gestiscono la logica di business e la comunicazione con il backend Guard : Proteggono l'accesso alle funzionalit\u00e0 in base all'autenticazione Shared : Contiene componenti comuni a molteplici pagine/componenti. In questo caso viene usato per la Navbar Features : Le funzionalit\u00e0 sono organizzate in features. Ciascuna feature pu\u00f2 contenere i componenti delle pagine (Film e Login in questo caso), e un ulteriore cartella con dentro componenti minori che possono essere utilizzati in altre pagine/componenti Dipendenze Angular Core e Common Angular Material RxJS Angular Router Flusso di Autenticazione L'autenticazione \u00e8 gestita in un approccio stateless tramite token JWT (JSON Web Token). Processo di Login L'utente invia credenziali (username e password) al backend Il backend verifica le credenziali contro il database Se valide, genera un token JWT firmato con una chiave segreta Il token viene restituito al client Il client memorizza il token nel localStorage Per le richieste successive, il token viene inviato nell'header Authorization Verifica del Token Per ogni richiesta autenticata, il client include il token JWT nell'header Il backend cattura e verifica l'autenticit\u00e0 del token con la classe JWTFilter usando la chiave segreta Se valido, estrae l'identit\u00e0 dell'utente e i ruoli La richiesta viene processata in base ai permessi dell'utente e/o endpoint chiamato Diagramma di Sequenza di Autenticazione Accesso alle API di Programmazione Il sistema offre due endpoint per accedere ai dati di programmazione: 1. Endpoint per utenti autenticati (richiede JWT) GET /api/programmazione Questo endpoint \u00e8 protetto tramite JWT e permette di visualizzare lo storico completo delle programmazioni, con possibilit\u00e0 di filtraggio per data. 2. Endpoint pubblico (non richiede autenticazione) GET /api/programmazione/settimana-corrente Questo endpoint \u00e8 accessibile pubblicamente e restituisce solo le programmazioni della settimana corrente. \u00c8 pensato per sistemi di visualizzazione esterni o per utenti non registrati.","title":"Architettura"},{"location":"architettura/#architettura-del-sistema","text":"","title":"Architettura del Sistema"},{"location":"architettura/#backend","text":"Il backend \u00e8 stato strutturato seguendo le indicazioni standard del pattern MVC","title":"Backend"},{"location":"architettura/#package-principali","text":"Model : Rappresentano le entit\u00e0 del dominio, mappate direttamente sul DB tramite l'ORM di Hibernate Repository : Si interfacciano con il Database, estendono JpaRepository in modo da offrire operazioni standard di CRUD gi\u00e0 implementate sulle entit\u00e0 Controller : Gestiscono le richieste HTTP e definiscono gli endpoint dell'API REST Service : Implementano la logica di business Config : Configurazioni di base per CSRF, CORS, Middleware per Logging e controllo JWT, Esclusione URL da autenticazione obbligatoria","title":"Package principali"},{"location":"architettura/#dipendenze","text":"Definite nel pom.xml del backedn Spring Boot Web Spring Data JPA Spring Security JWT PostgreSQL","title":"Dipendenze"},{"location":"architettura/#frontend-angular-19","text":"Comunicazione con il backend tramite chiamate http all'API Rest Gestione dello stato dell'applicazione, principalmente sullo stato di autenticazione dell'utente Gestione route guard in base allo stato di autenticazione dell'utente","title":"Frontend (Angular 19)"},{"location":"architettura/#package-principali_1","text":"Core : Contiene logica fondamentale, servizi e guard Servizi : Gestiscono la logica di business e la comunicazione con il backend Guard : Proteggono l'accesso alle funzionalit\u00e0 in base all'autenticazione Shared : Contiene componenti comuni a molteplici pagine/componenti. In questo caso viene usato per la Navbar Features : Le funzionalit\u00e0 sono organizzate in features. Ciascuna feature pu\u00f2 contenere i componenti delle pagine (Film e Login in questo caso), e un ulteriore cartella con dentro componenti minori che possono essere utilizzati in altre pagine/componenti","title":"Package Principali"},{"location":"architettura/#dipendenze_1","text":"Angular Core e Common Angular Material RxJS Angular Router","title":"Dipendenze"},{"location":"architettura/#flusso-di-autenticazione","text":"L'autenticazione \u00e8 gestita in un approccio stateless tramite token JWT (JSON Web Token).","title":"Flusso di Autenticazione"},{"location":"architettura/#processo-di-login","text":"L'utente invia credenziali (username e password) al backend Il backend verifica le credenziali contro il database Se valide, genera un token JWT firmato con una chiave segreta Il token viene restituito al client Il client memorizza il token nel localStorage Per le richieste successive, il token viene inviato nell'header Authorization","title":"Processo di Login"},{"location":"architettura/#verifica-del-token","text":"Per ogni richiesta autenticata, il client include il token JWT nell'header Il backend cattura e verifica l'autenticit\u00e0 del token con la classe JWTFilter usando la chiave segreta Se valido, estrae l'identit\u00e0 dell'utente e i ruoli La richiesta viene processata in base ai permessi dell'utente e/o endpoint chiamato","title":"Verifica del Token"},{"location":"architettura/#diagramma-di-sequenza-di-autenticazione","text":"","title":"Diagramma di Sequenza di Autenticazione"},{"location":"architettura/#accesso-alle-api-di-programmazione","text":"Il sistema offre due endpoint per accedere ai dati di programmazione:","title":"Accesso alle API di Programmazione"},{"location":"architettura/#1-endpoint-per-utenti-autenticati-richiede-jwt","text":"GET /api/programmazione Questo endpoint \u00e8 protetto tramite JWT e permette di visualizzare lo storico completo delle programmazioni, con possibilit\u00e0 di filtraggio per data.","title":"1. Endpoint per utenti autenticati (richiede JWT)"},{"location":"architettura/#2-endpoint-pubblico-non-richiede-autenticazione","text":"GET /api/programmazione/settimana-corrente Questo endpoint \u00e8 accessibile pubblicamente e restituisce solo le programmazioni della settimana corrente. \u00c8 pensato per sistemi di visualizzazione esterni o per utenti non registrati.","title":"2. Endpoint pubblico (non richiede autenticazione)"},{"location":"installazione/","text":"Guida all'avvio Per istruzioni avviare il progetto in locale, consultare il readme del repository","title":"Avvio del progetto"},{"location":"installazione/#guida-allavvio","text":"Per istruzioni avviare il progetto in locale, consultare il readme del repository","title":"Guida all'avvio"},{"location":"modelli/","text":"Modelli e Entit\u00e0 Utente @Table(name = \"utenti\") @Entity public class Utente implements UserDetails { @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(nullable = false) private int id; @Column(nullable = false) private String username; @Column(nullable = false) private String password; @Enumerated(EnumType.STRING) @Column(nullable = false) private Ruolo ruolo; @CreationTimestamp @Column(nullable = false, name = \"created_at\") private Date createdAt; @UpdateTimestamp @Column(nullable = false, name = \"updated_at\") private Date updatedAt; // ... } Film @Entity public class Film { @Id @GeneratedValue private int id; private String titolo; private String genere; private LocalDate dataUscita; // ... } Sala @Entity @Table(name = \"sale\") public class Sala { @Id @GeneratedValue private int id; private String codice; private int capienza; private boolean isIMAX; // ... } Programmazione @Entity @Table(name = \"programmazione\") public class Programmazione { @Id @GeneratedValue private int id; @ManyToOne @JoinColumn(name = \"film_id\") private Film film; @ManyToOne @JoinColumn(name = \"sala_id\") private Sala sala; private LocalDateTime dataOraInizio; private LocalDateTime dataOraFine; // ... } Relazioni tra entit\u00e0 Film e Programmazione : uno-a-molti. Un film pu\u00f2 avere molte programmazioni, ma ogni programmazione \u00e8 associata a un solo film. Sala e Programmazione : uno-a-molti. Una sala pu\u00f2 aver ospitato molte programmazioni, ma ogni programmazione avviene in una sola sala Schema del Database Gli schemi DDL e il diagramma sono stati generati direttamente da DBeaver. Tabella film CREATE TABLE film ( id int8 NOT NULL, genere varchar(255) NULL, titolo varchar(255) NULL, data_uscita date NULL, CONSTRAINT film_pkey PRIMARY KEY (id) ); Tabella sale CREATE TABLE sale ( id int4 NOT NULL, capienza int4 NOT NULL, isimax bool NOT NULL, codice varchar(255) NULL, CONSTRAINT sale_pkey PRIMARY KEY (id) ); Tabella utenti CREATE TABLE utenti ( id int8 NOT NULL, created_at timestamp(6) NOT NULL, \"password\" varchar(255) NOT NULL, ruolo varchar(255) NOT NULL, updated_at timestamp(6) NOT NULL, username varchar(255) NOT NULL, CONSTRAINT utenti_pkey PRIMARY KEY (id), CONSTRAINT utenti_ruolo_check CHECK (((ruolo)::text = ANY ((ARRAY['USER'::character varying, 'ADMIN'::character varying])::text[]))) ); Tabella programmazione CREATE TABLE programmazione ( id int4 NOT NULL, data_ora_fine timestamp(6) NULL, data_ora_inizio timestamp(6) NULL, film_id int4 NULL, sala_id int4 NULL, CONSTRAINT programmazione_pkey PRIMARY KEY (id), CONSTRAINT fkpk1y86d0vkqg17yb010huq9pr FOREIGN KEY (sala_id) REFERENCES sale(id), CONSTRAINT fkqusqe4h0ylsxia45wxx5rriua FOREIGN KEY (film_id) REFERENCES film(id) ); Diagramma delle tabelle","title":"Modelli"},{"location":"modelli/#modelli-e-entita","text":"","title":"Modelli e Entit\u00e0"},{"location":"modelli/#utente","text":"@Table(name = \"utenti\") @Entity public class Utente implements UserDetails { @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(nullable = false) private int id; @Column(nullable = false) private String username; @Column(nullable = false) private String password; @Enumerated(EnumType.STRING) @Column(nullable = false) private Ruolo ruolo; @CreationTimestamp @Column(nullable = false, name = \"created_at\") private Date createdAt; @UpdateTimestamp @Column(nullable = false, name = \"updated_at\") private Date updatedAt; // ... }","title":"Utente"},{"location":"modelli/#film","text":"@Entity public class Film { @Id @GeneratedValue private int id; private String titolo; private String genere; private LocalDate dataUscita; // ... }","title":"Film"},{"location":"modelli/#sala","text":"@Entity @Table(name = \"sale\") public class Sala { @Id @GeneratedValue private int id; private String codice; private int capienza; private boolean isIMAX; // ... }","title":"Sala"},{"location":"modelli/#programmazione","text":"@Entity @Table(name = \"programmazione\") public class Programmazione { @Id @GeneratedValue private int id; @ManyToOne @JoinColumn(name = \"film_id\") private Film film; @ManyToOne @JoinColumn(name = \"sala_id\") private Sala sala; private LocalDateTime dataOraInizio; private LocalDateTime dataOraFine; // ... }","title":"Programmazione"},{"location":"modelli/#relazioni-tra-entita","text":"Film e Programmazione : uno-a-molti. Un film pu\u00f2 avere molte programmazioni, ma ogni programmazione \u00e8 associata a un solo film. Sala e Programmazione : uno-a-molti. Una sala pu\u00f2 aver ospitato molte programmazioni, ma ogni programmazione avviene in una sola sala","title":"Relazioni tra entit\u00e0"},{"location":"modelli/#schema-del-database","text":"Gli schemi DDL e il diagramma sono stati generati direttamente da DBeaver.","title":"Schema del Database"},{"location":"modelli/#tabella-film","text":"CREATE TABLE film ( id int8 NOT NULL, genere varchar(255) NULL, titolo varchar(255) NULL, data_uscita date NULL, CONSTRAINT film_pkey PRIMARY KEY (id) );","title":"Tabella film"},{"location":"modelli/#tabella-sale","text":"CREATE TABLE sale ( id int4 NOT NULL, capienza int4 NOT NULL, isimax bool NOT NULL, codice varchar(255) NULL, CONSTRAINT sale_pkey PRIMARY KEY (id) );","title":"Tabella sale"},{"location":"modelli/#tabella-utenti","text":"CREATE TABLE utenti ( id int8 NOT NULL, created_at timestamp(6) NOT NULL, \"password\" varchar(255) NOT NULL, ruolo varchar(255) NOT NULL, updated_at timestamp(6) NOT NULL, username varchar(255) NOT NULL, CONSTRAINT utenti_pkey PRIMARY KEY (id), CONSTRAINT utenti_ruolo_check CHECK (((ruolo)::text = ANY ((ARRAY['USER'::character varying, 'ADMIN'::character varying])::text[]))) );","title":"Tabella utenti"},{"location":"modelli/#tabella-programmazione","text":"CREATE TABLE programmazione ( id int4 NOT NULL, data_ora_fine timestamp(6) NULL, data_ora_inizio timestamp(6) NULL, film_id int4 NULL, sala_id int4 NULL, CONSTRAINT programmazione_pkey PRIMARY KEY (id), CONSTRAINT fkpk1y86d0vkqg17yb010huq9pr FOREIGN KEY (sala_id) REFERENCES sale(id), CONSTRAINT fkqusqe4h0ylsxia45wxx5rriua FOREIGN KEY (film_id) REFERENCES film(id) );","title":"Tabella programmazione"},{"location":"modelli/#diagramma-delle-tabelle","text":"","title":"Diagramma delle tabelle"}]}